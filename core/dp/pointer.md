# 设计模式简介

设计模式分为 3 类 23 种：创建型模式，结构型模式，行为型模式

创建型模式（5 种）：关注类怎么创建

1. 工厂方法模式
2. 抽象工厂模式：批量创建类，方便扩展
3. 单例模式（饿汉式，懒汉式）：保证一个类只有一个实例，并提供一个访问它的全局访问点。
4. 建造者模式：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示，可以控制类的属性创建顺序
5. 原型模式（克隆模式）：通过对象创建对象，不通过类创建对象（cpp 中的深拷贝）

结构型模式（7 种）：关注多个类之间怎么协作

1. 适配器模式：加一层（套壳），使不兼容的接口兼容
2. 装饰器模式：动态地为对象添加额外的功能。它通过将对象包装在一个装饰器类中，来扩展原有对象的行为，而无需修改原有对象的结构。
3. 代理模式：允许通过代理对象来间接访问目标对象，以控制对目标对象的访问。代理模式在许多情况下都被使用，例如延迟加载、权限控制、缓存等。
4. 外观模式：提供一个统一的高层接口，来简化使用，屏蔽细节
5. 桥接模式：将抽象部分与其具体实现部分分离，使它们可以独立地变化。该模式通过将继承关系转化为组合关系，使得抽象和实现可以独立地进行扩展。
6. 组合模式：用于将对象组合成树状结构以表示"部分-整体"的层次结构。
7. 享元模式：将一个对象的状态分为内部状态和外部状态。内部状态可以被多个对象共享，而外部状态取决于具体的场景，每个对象都有不同的外部状态。然后通过共享对象来最大限度地减少内存使用和提高性能。

行为型模式（11 种）：关注类的行为，主要是方法（函数）

1. 策略模式：允许在运行时选择算法的行为。在不改变客户端代码的情况下，可以动态地选择或切换不同的算法。
2. 模板方法模式：定义了一个操作中的算法骨架，而将一些步骤延迟到子类中实现。父类定义算法的结构，并将一些具体步骤的实现委托给子类。这样可以确保算法的结构保持不变，同时允许子类根据需要提供自己的实现细节。
3. 观察者模式：观察者模式通过解耦发布者和订阅者之间的关系，实现了松耦合的设计，并且允许多个观察者同时订阅一个主题，从而实现一对多的依赖关系。这种模式可用于许多场景，例如事件监听、GUI 开发等。
4. 迭代子模式
5. 责任链模式：责任链模式通过将请求的发送者和接收者解耦，允许多个对象按照顺序依次处理请求，从而实现动态组合对象的处理流程。这种模式可用于许多场景，例如请求处理、日志记录等。
6. 命令模式
7. 备忘录模式
8. 状态模式
9. 访问者模式
10. 中介者模式
11. 解释器模式

注意：

- Python 是动态语言，不是能完全契合所有的设计模式

- 适当地使用一些设计模式可以写出漂亮的代码，但不要炫技，在合适的场景用合适的设计模式。

- 设计模式在写大型项目，开源框架，提供给别人用的时候用处比较大，设计模式是为了供高层实现者简单调用的。

<table>
    <!-- 1 -->
    <tr>
        <td rowspan="2">第 1 部分-适应设计模式</td>
        <td>Iterator 模式：一个一个遍历</td>
    </tr>
    <tr>
        <td>Adapter 模式：加个“适配器”以便于复用</td>
    </tr>
    <!-- 2 -->
    <tr>
        <td rowspan="2">第 2 部分-交给子类</td>
        <td>Template Method 模式：将具体处理交给子类</td>
    </tr>
    <tr>
        <td>Factory Method 模式：将实例的生成交给子类</td>
    </tr>
    <!-- 3 -->
    <tr>
        <td rowspan="4">第 3 部分-生成实例</td>
        <td>Singleton 模式：只有一个实例</td>
    </tr>
    <tr>
        <td>Prototype 模式：通过复制生成实例</td>
    </tr>
    <tr>
        <td>Builder 模式：组装复杂的实例</td>
    </tr>
    <tr>
        <td>Abstract Factory 模式：将关联零件组装成产品</td>
    </tr>
    <!-- 4 -->
    <tr>
        <td rowspan="2">第 4 部分-分开考虑</td>
        <td>Bridge 模式：将类的功能层次结构与实现层次结构分离</td>
    </tr>
    <tr>
        <td>Strategy 模式：整体地替换算法</td>
    </tr>
    <!-- 5 -->
    <tr>
        <td rowspan="2">第 5 部分-一致性</td>
        <td>Composite 模式：容器与内容的一致性</td>
    </tr>
    <tr>
        <td>Decorator 模式：装饰边框与被装饰物的一致性</td>
    </tr>
    <!-- 6 -->
    <tr>
        <td rowspan="2">第 6 部分-访问数据结构</td>
        <td>Visitor 模式：访问数据结构并处理数据</td>
    </tr>
    <tr>
        <td>Chain of Responsibility 模式：推卸责任</td>
    </tr>
    <!-- 7 -->
    <tr>
        <td rowspan="2">第 7 部分-简单化</td>
        <td>Facade 模式：简单窗口</td>
    </tr>
    <tr>
        <td>Mediator 模式：只有一个仲裁者</td>
    </tr>
    <!-- 8 -->
    <tr>
        <td rowspan="3">第 8 部分-管理状态</td>
        <td>Observer 模式：发送状态变化通知</td>
    </tr>
    <tr>
        <td>Memento 模式：保存对象状态</td>
    </tr>
    <tr>
        <td>State 模式：用类表示状态</td>
    </tr>
    <!-- 9 -->
    <tr>
        <td rowspan="4">第 9 部分-避免浪费</td>
        <td>Flyweight 模式：共享对象，避免浪费</td>
    </tr>
    <tr>
        <td>Proxy 模式：只在必要时生成实例</td>
    </tr>
    <tr>
        <td>Command 模式：命令也是类</td>
    </tr>
    <tr>
        <td>Interpreter 模式：语法规则也是类</td>
    </tr>
</table>
