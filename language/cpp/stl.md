# 1. 容器 Containers

序列式容器：

- array（静态顺序表）
- bitset（位图）
- string（字符串）
- vector（动态顺序表）
- forward_list（带头节点的循环单链表）
- list（带头节点的双向循环链表）
- deque（动态二维数组）

关联式容器：

- 红黑树结构（map, set, multimap, multiset）
- 哈希结构（unordered_map, unordered_multimap, unordered_set, unordered_multiset）

容器对象的成员函数（容器通用函数）：

- .size()：容器内的元素个数，无符号整型。
- .empty()：判断容器是否为空，返回一个 bool 值。
- .front()：返回容器第一个元素。
- .back()：返回容器最后一个元素。
- .begin()：指向容器第一个元素的指针。
- .end()：指向容器最后一个元素的下一个位置的指针。
- .swap()：交换两个容器的内容。
- ::iterator：迭代器。

# 2. 算法 Algorithms

sort  
reverse  
merge  
find  
max/min  
next_permutation  
prev_permutation  
...

# 3. 迭代器 Iterators

概念：

- 迭代器是一种设计模式，让用户通过特定的接口访问容器的数据，不需要了解容器底层所采用的数据结构概念。
- 迭代器应该由容器设计者负责提供，然后容器按照约定给出统一的接口即可
- 容器迭代器的设计必须结合容器的底层数据结构，容器底层结构不同迭代器的实现原理也不同

反向迭代器：是一种适配器，其对正向迭代器进行了封装

迭代器是一个广义的指针，可以是指针， 也可以是对其进行类似指针操作的对象。

模板使算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型。

# 4. 适配器 Adapters

概念：适配器（配接器）是一种设计模式，它可以将一个类的接口转换成用户希望的另一个类的接口，使原本接口不兼容的类可以一起工作

容器适配器：容器适配器是一种封装了底层容器（比如 deque、list 或 vector）的数据结构，提供了特定功能的接口。

- stack：底层是对 deque 的重新封装
- queue：底层是对 deque 的重新封装适配器
- priority_queue：优先级队列（默认情况下是大堆）

迭代器适配器：反向迭代器

函数适配器

# 5. 仿函数/函数对象 Functors

概念：仿函数对象是一种具有函数特征的对象，调用者可以像函数一样使用该对象，该对象所在类必须自定义函数调用运算符 operator()

可调用对象：函数指针，仿函数，lambda 表达式，包装器

# 6. 分配器 Allocators

概念：

- 空间配置器的作用，就是为各个容器高效的管理空间的申请与回收概念
- STL 容器需要频繁向系统申请／释放小块内存块，容易造成内存碎片，同时会影响程序的运行效率，因此需要空间配置器来对内存进行管理空间配置器

实现原理：

- 一级空间配置器
  - 如果一次申请／释放的内存空间大于 128 字节，那么直接向一级空间配置器进行申请／释放
  - 一级空间配置器对 malloc 和 free 进行了封装，并增加了 cpp 中 set_new_handle 思想
- 二级空间配置器
  - 如果一次申请／释放的内存空间小于等于 128 字节，那么需要向二级空间配置器进行申请／释放
  - 二级空间配置器采用内存池的技术来提高申请空间的速度以及减少额外空间的浪费，采用哈希桶的方式对内存池中的内存块进行高效管理
  - 二级空间配置器中的哈希桶以 8 的整数倍进行向上对齐，当需要申请／释放内存时直接找到对应的哈希桶进行申请／释放即可
  - 如果对应哈希桶下面已经没有内存块了，那么就需要向一级空间配置器申请一块大内存，将大内存切分后挂在该哈希桶下以供申请

# 其他

pair 函数
